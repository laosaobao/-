#### node.js 使用ES6模块化

![63741923969](VUE.assets/1637419239695.png)

npm  init -y 快速初始化创建package.json   添加 “type‘:"module"



#### 默认导出语法  export default(默认导出的成员)

![63741975265](VUE.assets/1637419752651.png)

 

#### 默认导入 import xx from xxxx

![63742005332](VUE.assets/1637420053326.png)

注：只能做一次默认导出  export default

![63742038072](VUE.assets/1637420380724.png)

导入时，变量名随意，合法即可



#### 按需导出/导入

![63742098671](VUE.assets/1637420986715.png)

#### 按需导入  使用{}，变量名必须和导出时一致，可使用as重命名

![63742102391](VUE.assets/1637421023917.png)

![63742118418](VUE.assets/1637421184188.png)

![63742158423](VUE.assets/1637421584232.png)



#### 直接导入并执行模块中的代码

![63742176998](VUE.assets/1637421769980.png)





## Promise

#### 回调地狱

![63742200950](VUE.assets/1637422009505.png)

![63748582899](VUE.assets/1637485828994.png)

#### promise解决fs.readFile()回调地狱

需要按顺序读取文件，readFile()是异步读取 直接多次调用无法保证读取顺序，需要嵌套在readFile（）方法的回调函数里，变成"回调地狱"(多个回调嵌套)

![63748736943](VUE.assets/1637487369438.png)

![63748770497](VUE.assets/1637487704975.png)

![63748830234](VUE.assets/1637488302346.png)

.catch捕捉错误

![63748889535](VUE.assets/1637488895359.png)

#### promise.all() 

![63749080138](VUE.assets/1637490801383.png)



#### Promise.race()

 ![63749109399](VUE.assets/1637491093995.png)

####  自己封装getFile()方法，通过Promise实现

![63749863437](VUE.assets/1637498634378.png)



### 下图是错误解释

![63749619777](VUE.assets/1637496197779.png)

上图是**错误**的，resolve和reject是promise类里自定义的变量(或者标记),

new Promise时，内部定义的方法就已经执行。正常操作是在定义内部需要执行的方法时根据执行成功或者失败，设置调用resolve()或reject()方法，**而resolve()和reject()方法是Promise对象自身封装的方法**，调用resolve()或reject()方法操作，是把执行成功or失败以及获取到的数据(调用resolve时作为形参传入)保存在Promise自身定义的变量里。

外部调用then方法时，就会**根据对象里保存的成功或失败结果**，执行用户给then方法传入的成功或失败回调函数

同时也将需要传递的数据传入回调方法中。



所以使用Promise时，需要在.Promise()后.then，.Promise().then()，在then里定义成功回调函数，才可以拿到结果值(赋值或者return)

因为then方法是Promise对象里的方法，写代码时不调用then或者不传递成功回调，就不会对之前resolve()方法保存在Promise对象里的结果数据做任何操作，也就无法拿到结果值。

需要在回调函数里设置return，也就是.then(成功function(){return 值}) 才能拿到返回的结果值。

所以在用Promise封装操作时，操作内容需要调用resolve()方法，并且外部调用then传入回调函数，才能拿到结果值。

如果是**await方式**，await可以直接提取内部执行resolve()方法时保存在Promise对象里的结果值，所以使用await就不需要使用then()



![63749643325](VUE.assets/1637496433257.png)

#### async/await  (ES8出现)

![63749781407](VUE.assets/1637497814074.png)

![63749905580](VUE.assets/1637499055801.png)

注意事项

![63749977030](VUE.assets/1637499770300.png)



#### EventLoop

![63750007576](VUE.assets/1637500075767.png)

![63750026085](VUE.assets/1637500260854.png)

#### 宏任务和微任务

![63750150954](VUE.assets/1637501509547.png)

![63750228994](VUE.assets/1637502289947.png)

注：new Promise(function(){}) 是同步任务，会立即执行function函数的内容



## Webpack

#### 初始化

![63750955818](VUE.assets/1637509558187.png)

#### 打包

![63758584183](VUE.assets/1637585841833.png)

#### 修改入口出口

![63758645738](VUE.assets/1637586457381.png)

![63758647917](VUE.assets/1637586479178.png)

![63758671681](VUE.assets/1637586716818.png)

#### HtmlWebpackPlugin 插件 自动生成入口html文件，并引入打包好的js文件

![63758792574](VUE.assets/1637587925741.png)

![63758795580](VUE.assets/1637587955802.png)

#### 打包css

css&style加载器

在打包入口的.js文件中import css

![63758861412](VUE.assets/1637588614120.png)

直接import的css文件无法识别 需要安装css loader style loader

![63758873060](VUE.assets/1637588730603.png)

![63758877519](VUE.assets/1637588775197.png)

#### less-loader

![63758897322](VUE.assets/1637588973223.png)

#### assert module资源模块  webpack5自带 打包静态资源文件

![63759255219](VUE.assets/1637592552199.png)

![63759259410](VUE.assets/1637592594106.png)

打包fonts文件

![63759343202](VUE.assets/1637593432020.png)



#### babel  babel-loader  (实现对js语法降级解决兼容问题)

![63767214330](VUE.assets/1637672143300.png)



webpack开发服务器

![63767323071](VUE.assets/1637673230718.png)

![63767356995](VUE.assets/1637673569959.png)

端口

![63767366677](VUE.assets/1637673666777.png)



## Vue

#### vue/cli 脚手架创建项目

npm install  @vue/cli -g  安装vue/cli

![63767874744](VUE.assets/1637678747440.png)

npm run serve开启热更新服务器

![63768069397](VUE.assets/1637680693972.png)



#### @vue/cli配置端口号

vue.config.js

![63768079899](VUE.assets/1637680798990.png)



#### eslint代码检查工具

![63768124674](VUE.assets/1637681246744.png)

![63768132900](VUE.assets/1637681329009.png)



#### 单Vue文件开发方式

![63776189931](VUE.assets/1637761899316.png)



#### Vue  插值表达式

![63776454052](VUE.assets/1637764540527.png)

MVVM设计模式

![63776495305](VUE.assets/1637764953053.png)



#### V-bind

![63776538480](VUE.assets/1637765384808.png)

#### v-on绑定事件

![63776571412](VUE.assets/1637765714128.png)

#### this指向当前export的对象

![63776583309](VUE.assets/1637765833098.png)

#### @事件名=“函数”

![63776586399](VUE.assets/1637765863996.png)

#### 接收事件对象(event)

![63776600461](VUE.assets/1637766004615.png)

####  v-on事件修饰符

![63776653583](VUE.assets/1637766535835.png)

#### 按键修饰符

![63776723723](VUE.assets/1637767237236.png)



#### v-model   双向绑定

![63777151072](VUE.assets/1637771510728.png)

![63777154432](VUE.assets/1637771544320.png)

![63777193654](VUE.assets/1637771936543.png)

![63777190060](VUE.assets/1637771900607.png)



![63777220564](VUE.assets/1637772205647.png)



#### v-model修饰符

![63785109313](VUE.assets/1637851093136.png)

v-text  v-html

![63785157117](VUE.assets/1637851571178.png)



#### v-show  v-if

![63785205807](VUE.assets/1637852058071.png)

![63785214816](VUE.assets/1637852148164.png)



#### V-for 

![63785384336](VUE.assets/1637853843360.png)



#### 补充：js里引入图片

![63785492767](VUE.assets/1637854927672.png)



#### v-for 更新检测

单纯改变数组中某个元素的值，不会触发更新，想要触发更新可采用this.$set()修改值

![63800031797](VUE.assets/1638000439650.png)





#### 虚拟dom

![63800353300](VUE.assets/1638003533004.png)

![63800351554](VUE.assets/1638003515542.png)

![63800369694](VUE.assets/1638003696946.png)

#### v-for  :key作用

![63801001016](VUE.assets/1638010010167.png)

值为索引时，li中的输入框还在原位置，没有跟随"老二，老三"，因为**diff算法**更新时尽量复用原标签，数组插入值，原索引对应的值发生了变化，更新时尽量复用原标签，所以只更新了对应的value，后面的输入框没有更新还在原位置



值为自定义id时，插入新数据，原数据对应的id不变，更新时尽量复用原标签，所以"老二，老三"对应的li标签不改变，直接插入新li，所以原值为“2，3”的输入框能够继续跟随"老二，老三"

![63801014861](VUE.assets/1638010148617.png)

![63801005266](VUE.assets/1638010052666.png)

![63801007642](VUE.assets/1638010076420.png)



#### 动态class

![63801785061](VUE.assets/1638017873686.png)

![63801789207](VUE.assets/1638017892079.png)

#### 动态style

![63801816306](VUE.assets/1638018163065.png)

 

#### 过滤器

![63808586786](VUE.assets/1638085867862.png)

#### 全局方式定义过滤器  Vue.filter

打包入口main.js中定义

![63808597015](VUE.assets/1638085970151.png)

#### 局部方式定义过滤器  filters{}

![63808603157](VUE.assets/1638086031574.png)

#### 过滤器传参 or 多过滤器

![63808627789](VUE.assets/1638086277890.png)

![63808630806](VUE.assets/1638086308060.png)



#### 计算属性 computed

![63808788985](VUE.assets/1638087889851.png)

![63808792816](VUE.assets/1638087928162.png)

#### 计算属性_缓存

计算属性的优势：有缓存，依赖项不变，从缓存中取值，减少运算

![63808816747](VUE.assets/1638088167471.png)

arry.reduce(),可用于计算累加累减

![63808989102](VUE.assets/1638089891020.png)

toFixed(n) 保留n位小数



#### 计算属性_完整写法

用**v-model双向绑定**给计算属性赋值或取值时，要用完整写法，给计算属性添加get set方法

![63809092222](VUE.assets/1638090922221.png)

![63809090762](VUE.assets/1638090907620.png)

补：arr.every（）遍历每个值，当有不符合条件的值时直接返回



#### 侦听器_watch

![63809308696](VUE.assets/1638093086969.png)

#### 深度侦听(侦听复杂数据类型 对象等)

![63809509634](VUE.assets/1638095096343.png)



#### 组件_基本使用

![63810670407](VUE.assets/1638106704078.png)

![63810774419](VUE.assets/1638107744195.png)

#### style 的scoped的原理

![63810689374](VUE.assets/1638106893745.png)

### 组件通信

#### 父组件 →子组件 传值

![63811078093](VUE.assets/1638110780934.png)

先在子组件props中定义接收的变量

![63811070023](VUE.assets/1638110700238.png)

![63811057555](VUE.assets/1638110575558.png)

#### 单向数据流 

![63811199445](VUE.assets/1638111994453.png)



#### 组件通信 子向父

![63811351241](VUE.assets/1638113512415.png)



**在父组件内，对引入的子组件绑定自定义事件和事件处理函数**

![63811357703](VUE.assets/1638113577034.png)





**在子组件内,用$emit() 触发调用父组件的自定义事件**

![63811366912](VUE.assets/1638113669120.png)





#### 跨组件传值  EventBus

在EventBus/ 中创建空白vue对象，两个组件共同引入该空白对象，

接收值的组件定义$on()监听事件

传值的组件调用$emit()触发事件

![63811512617](VUE.assets/1638115126178.png)

![63811551625](VUE.assets/1638115516250.png)

![63811553495](VUE.assets/1638115534950.png)





## 构子函数

![63836517438](VUE.assets/1638453059335.png)

#### 初始化

![63836683362](VUE.assets/1638453038291.png)



![63836691332](VUE.assets/1638453129413.png)

![63836696989](VUE.assets/1638453155655.png)

#### 挂载

![63836860442](VUE.assets/1638453202013.png)

![63836918378](VUE.assets/1638453264800.png)

![63836921510](VUE.assets/1638453290120.png)

![63836923358](VUE.assets/1638453309956.png)

#### 更新

![63836949558](VUE.assets/1638453391286.png)

![63845344858](VUE.assets/1638453448589.png)

#### 销毁

![63836969365](VUE.assets/1638453481244.png)

![63837009304](VUE.assets/1638453530424.png)



#### axios

![63837196503](VUE.assets/1638453563189.png)

#### 可以用扩展运算符...

![63845367419](VUE.assets/1638453674190.png)



#### 配置全局默认基地址

![63845410253](VUE.assets/1638454102533.png)



#### ref获取原生dom元素

![63845430078](VUE.assets/1638454300786.png)

#### 获取组件对象

![63845524398](VUE.assets/1638455243987.png)



#### vue更新DOM异步问题

![63845560851](VUE.assets/1638455608512.png)

#### 使用$nextTick解决dom异步更新问题

![63845581993](VUE.assets/1638455819936.png)

![63845569665](VUE.assets/1638455696651.png)



$nextTick

![63845673489](VUE.assets/1638456734897.png)



#### 组件里name属性作用

![63845710837](VUE.assets/1638457108373.png)



新知识点，对props接收的变量进行校验

![63845781657](VUE.assets/1638457816579.png)

![63845791777](VUE.assets/1638457917777.png)

#### 将axios挂载到全局vue

![63845828118](VUE.assets/1638458281189.png)





#### 动态组件

<component :is=""></component> 内置组件

变量名comName可以随意 属性值必须是想要展示的并且已注册的**组件名称**

![63854176603](VUE.assets/1638541766030.png)



#### 组件缓存

![63854258180](VUE.assets/1638542581803.png)

![63854260378](VUE.assets/1638542603785.png)



#### 组件激活和非激活(新生命周期方法)

![63854282019](VUE.assets/1638542820191.png)



#### 组件插槽

<slot></slot>

![63854373075](VUE.assets/1638543730756.png)

![63854374690](VUE.assets/1638543746906.png)



#### 一个组件多个slot

![63854568739](VUE.assets/1638545687391.png)

![63854579575](VUE.assets/1638545795759.png)



#### 作用域插槽

![63862345736](VUE.assets/1638623457367.png)

**上述"scope"可以随意命名，该变量名会自动绑定slot上所有属性和值**

![63862361606](VUE.assets/1638623616062.png)



#### 自定义指令

![63862663019](VUE.assets/1638626630197.png)

**全局**

![63862687425](VUE.assets/1638626874253.png)

**局部**

![63862692203](VUE.assets/1638626922033.png)

![63862705349](VUE.assets/1638627053492.png)



#### inserted指令所在标签被插入网页时执行，update指令对应数据或标签更新时执行

![63862766275](VUE.assets/1638627662750.png)

![63862771228](VUE.assets/1638627712287.png)



父传子，props接收值进行自定义校验 validator

![63862908787](VUE.assets/1638629087879.png)





## 路由

#### vue-router

基本使用

引入   路径@表示src的绝对地址

![63871535439](VUE.assets/1638715354399.png)

全局注册，设置规则

![63871517483](VUE.assets/1638715174831.png)

component里也可以写function

![63992398423](VUE.assets/1639923984238.png)

生成路由对象

![63871523160](VUE.assets/1638715231607.png)

路由对象注入vue实例

![63871528332](VUE.assets/1638715283326.png)

设置挂载点

![63871548733](VUE.assets/1638715487336.png)

![63871569670](VUE.assets/1638715696708.png)

hash值 指url上#后面内容

![63871575485](VUE.assets/1638715754850.png)



### 声明式导航

#### router-link (自动赋予被点击的active类名(可用来设置点击高亮))

![63871591869](VUE.assets/1638715918693.png)

![63871620039](VUE.assets/1638716200398.png)

#### 声明式导航-跳转传参

![63871641170](VUE.assets/1638716411708.png)

![63871656112](VUE.assets/1638716561120.png)

方式2：在路由规则上定义

![63871692124](VUE.assets/1638716921240.png)

![63871686513](VUE.assets/1638716865131.png)

![63871698878](VUE.assets/1638716988784.png)



#### 路由重定向

默认打开网页时，重定向到某个页面

添加匹配规则即可   redirect：

![63871726358](VUE.assets/1638717263582.png)



#### 路由404设置

![63871810879](VUE.assets/1638718108799.png)

#### 路由模式

![63871829079](VUE.assets/1638718290798.png)



#### 编程式导航

![63871868705](VUE.assets/1638718687058.png)

传参

![63871887808](VUE.assets/1638718878086.png)

![63871865781](VUE.assets/1638718657815.png)

方式2：添加name属性，用name属性进行跳转(需要修改路径时只需修改路由规则)

![63871881261](VUE.assets/1638718812612.png)

#### 编程式导航-跳转传参

使用path方式跳转，只能使用query方式传参

使用name方式跳转，则两者都可选

![63871919369](VUE.assets/1638719193691.png)



#### 路由嵌套

![63872132866](VUE.assets/1638721328667.png)



#### 声明式导航，active激活类名区别

精确匹配和模糊匹配

![63887522398](VUE.assets/1638875223986.png)

如：

![63887527702](VUE.assets/1638875277029.png)





#### 路由守卫(权限判断)

![63887639899](VUE.assets/1638876398990.png)

![63887631107](VUE.assets/1638876311077.png)



## vant组件库

![63887653864](VUE.assets/1638876538644.png)

引入所有

![63887698646](VUE.assets/1638876986466.png)

手动按需引入   引入组件 引入样式 手动注册

![63887846608](VUE.assets/1638878466089.png)



自动按需引入

babel-plugin-import

![63887884737](VUE.assets/1638878847370.png)

 

#### meta 元信息 保存路由对象额外信息

![63906081158](VUE.assets/1639060811580.png)

![63906087493](VUE.assets/1639060874937.png)

![63906083776](VUE.assets/1639060837762.png)



#### 二次封装axios和请求api(统一管理 避免请求散落在各个文件)

![63906337548](VUE.assets/1639063375483.png)

封装utils

![63906342957](VUE.assets/1639063429571.png)

封装每个页面对应的api请求

![63906350407](VUE.assets/1639063548132.png)

统一到index.js向外导出

![63906363581](VUE.assets/1639063696739.png)

![63906380940](VUE.assets/1639063809406-1639063810717.png)



Vant组件适配(px自动转成rem)

![63941108042](VUE.assets/1639411080425.png)

![63975384648](VUE.assets/1639753846482.png)

![63975387927](VUE.assets/1639753879276.png)

![63991949494](VUE.assets/1639919494946.png)





#### elementui  -select下拉框 v-model绑定获取选中的选项值

在select属性上加v-model绑定变量 可以获取下拉框的选中值

![63975902587](VUE.assets/1639759025870.png)



# Vue 中input或select绑定数字类型时的坑

要绑定数字类型，对应的value属性要加上v-bind, :value，不然还是字符类型

![image-20211218094858502](assets/image-20211218094858502.png)