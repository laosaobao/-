## 变量

驼峰命名

不以数字开头

区分大小写

不使用“关键字” ps：name也是关键字，尽量不使用

#### 数据类型

![63465331462](assets/1634653314620.png)

#### number

![63465348252](assets/1634653482529.png)

![63465417801](assets/1634654178019.png)

![63465401485](assets/1634654014852.png)



无穷大无穷小另外写法

![63465427879](assets/1634654278793.png)

isNaN()判断是否为非数字类型

![63465442425](assets/1634654424259.png)





#### String

![63465458377](assets/1634654583778.png)

![63465516362](assets/1634655163622.png)

#### Undefined和Null

![63465564823](assets/1634655648239.png)



#### typeof 检测数据类型

![63465577774](assets/1634655777749.png)



## 数据类型转换



#### 转字符串

![63465593889](assets/1634655938896.png)

#### 转换为数字类型

![63465608550](assets/1634656085505.png)

#### 转换为布尔类型

![63465651471](assets/1634656514717.png)

#### 解释型语言

![63465672602](assets/1634656726020.png)









#### 浮点数精度问题

![63473722327](assets/1634737223277.png)

#### 递增递减

++  --

++a 先自增再返回值，a++先返回原值再自加



#### **比较运算符== !=** 

![63473802322](assets/1634738023227.png)

![63473816914](assets/1634738169145.png)



#### 逻辑与 &&

短路运算

![63473874746](assets/1634738747469.png)

#### 赋值运算符

![63473912891](assets/1634739128917.png)



#### 运算符优先级

![63473928083](assets/1634739280831.png)



#### 三元表达式

![63474071837](assets/1634740718377.png)

#### switch case

![63474081721](assets/1634740817212.png)

表达式值和case值匹配时必须全等，即数据类型和内容一样

![63474093853](assets/1634740938534.png)

case不写break会继续执行下一个case(即使下一个case值和表达式值不符)，直到break

![63474110286](assets/1634741102864.png)

switch效率更高，不需要多次判断



#### 数组

![63474230652](assets/1634742306521.png)

![63474232329](assets/1634742323299.png)

追加

![63474262925](assets/1634742629255.png)



将旧数组某些符合条件的值存储到新数组 小技巧写法

newArr【newArr.length】完成新值添加和数组扩容

![63474299946](assets/1634742999463.png)



#### 形参实参匹配

![63482441602](assets/1634824416023.png)





#### arguments（不确定多少个参数传递）

![63482695595](assets/1634826955958.png)

![63482732405](assets/1634827324059.png)



#### 函数声明两种方式

![63483097289](assets/1634830972894.png)

用变量方式声明，函数为匿名函数，通过变量名调用，但变量名不是函数名



#### JavaScript预解析

将变量声明提升到顶部(变量的赋值不提升,在原位置)，然后再按顺序执行

#### 创建对象两种方式

![63506717024](assets/1635067170242.png)

二、var 对象={属性名:属性值}



#### 使用构造函数创建对象

![63506792152](assets/1635067921524.png)

![63506800161](assets/1635068001617.png)

**构造函数名首字母大写，不需要return就可以返回结果**

function 构造函数名(name){

//对象赋值用this

this.name=name

}

声明对象调用构造函数，加**new** ，var xx=new xxx()



#### for..in..循环，遍历数组或对象

![63506977167](assets/1635069771673.png)



#### MND文档查阅

![63507278894](assets/1635072788949.png)

 

#### Math

![63507894311](assets/1635078943112.png)

round()方法可以这样理解：

将括号内的数+0.5之后，向下取值，

比如：round(3.4)就是3.4+0.5=3.9，向下取值是3，所以round(3.4)=3; 

round(-10.5)就是-10.5+0.5=-10，向下取值就是-10，所以round(-10.5)=-10

#### Date

![63508017730](assets/1635080177307.png)

![63508008996](assets/1635080089961.png)

![63508081266](assets/1635080812669.png)

倒计时

![63508099686](assets/1635080996866.png)

####  创建数组两种方式

![63508143343](assets/1635081433438.png)



#### instanceof 判断是否为某个对象(例如判断数组)

![63508166824](assets/1635081668247.png)



#### 数组添加删除元素

![63508193832](assets/1635081938322.png)

返回的是数组长度

![63508200757](assets/1635082007572.png)

#### Array.sort() 坑

默认排序,按照字符串规则排序，如![63508229609](assets/1635082296091.png)

要实现升序/降序排序写法

![63508234162](assets/1635082341628.png)



#### 数组转字符串

![63508307679](assets/1635083076796.png)

#### 数组连接，截取，删除部分

![63508310411](assets/1635083104118.png)



#### String  indexof

![63508532347](assets/1635085323476.png)

![63508550306](assets/1635085503065.png)

![63508659286](assets/1635086592861.png)

区别：
1、substring：两个参数会比较大小来判断哪一个是起始位参数哪一个是结束位置参数，通俗的讲就是小的一个数会作为起始 位置参数，大的一个数会作为结束位置参数；
slice：则不会有这样的规则，只遵循大于0，从前面计数，小于0，从后面计数的原则。
2、substring：除了两个参数会比较大小调换位置外，还满足小于0时按0处理的规则；
slice：则是根据大于0和小于0来判断计数的前后顺序


####  replace()替换 split()分割并返回数组

![63508692644](assets/1635086926448.png)

![63508693932](assets/1635086939320.png)



#### 简单数据类型，复杂数据类型

特殊点：赋值为**null时，用typeof返回的是object类型**

![63508732542](assets/1635087325429.png)



## Web API

#### DOM

![63508877841](assets/1635088778412.png)

![63508920763](assets/1635089207635.png)

根据id获取元素

![63508900480](assets/1635089004802.png)



HTML5新增根据classname获取元素

![63508950309](assets/1635089503096.png)

![63508956835](assets/1635089568352.png)

innerText innerHTML

![63509024019](assets/1635090240194.png)

#### 修改css样式

![63509094610](assets/1635090946106.png)



#### 获取自定义属性值

![63516800376](assets/1635168003760.png)

![63516802121](assets/1635168021216.png)

![63516820467](assets/1635168204678.png)





#### H5自定义属性

![63516889551](assets/1635168895517.png)

自定义属性以 data-  开头



#### H5新增的获取自定义属性的方法

建议还是使用getAttribute

![63516915862](assets/1635169158627.png)





### 节点操作

#### 父节点

element.**parentNode**

![63517003258](assets/1635170032585.png)



#### 子节点

**childNodes** 返回子节点集合 但是包括元素节点和文本节点，麻烦

![63517008755](assets/1635170087554.png)

**children**非标准，但只返回子元素节点，各个浏览器都支持



#### 第一个子元素和最后一个子元素

firstChild    lastChild 但是如果**有文本节点(例如换行空格，也会返回)** 不靠谱

![63517027932](assets/1635170279328.png)



fitstElementChild    lastElementChild   有兼容性问题 ie9以上才支持

实际写法

![63517057921](assets/1635170579213.png)



#### 兄弟节点

nextSibling  previousSibling 包含文本节点

![63517140368](assets/1635171403686.png)

nextElementSibling  

![63517144759](assets/1635171447592.png)



#### 创建&添加节点

创建节点

![63517183690](assets/1635171836900.png)



添加节点

![63517186309](assets/1635171863095.png)

#### 删除节点

![63517269380](assets/1635172693806.png)

####  复制节点

![63517332421](assets/1635173324219.png)



#### 三种动态创建元素方式区别

![63517545095](assets/1635175450951.png)

若innerHTML采用**多次**拼接字符串的操作效率会很低(String不可变,每次拼接时会开辟新的内存空间存储新的字符串变量)





#### 注册事件(绑定事件)两种方式

![63517610456](assets/1635176104568.png)

![63517607862](assets/1635176078627.png)

还有detachEvent()

#### 删除事件

![63534724584](assets/1635347245845.png)

#### DOM事件流

![63525372011](assets/1635253720115.png)

![63525406062](assets/1635254060620.png)

![63525408514](assets/1635254085146.png)

**事件冒泡 、事件捕获 二者区别**

父元素和子元素都有触发事件时，触发顺序不同，事件冒泡从下到上，事件捕获从上到下

注：假如**父元素绑定了点击事件，子元素没绑定，点击子元素也会触发执行父元素的点击事件**





#### 事件对象

![63525450736](assets/1635254507368.png)

![63525547405](assets/1635255474052.png)

![63525549973](assets/1635255499734.png)

![63525595903](assets/1635255959037.png)



#### 事件委托

![63525781862](assets/1635257818629.png)



#### 鼠标事件对象

![63525829945](assets/1635258299455.png)



#### 常用键盘事件

![63525897666](assets/1635258976664.png)

![63525943254](assets/1635259432540.png)





## BOM

![63526069843](assets/1635260698432.png)

![63526121302](assets/1635261213021.png)



#### window.onload 窗口加载事件

![63526132204](assets/1635261322046.png)

![63526160496](assets/1635261604968.png)



#### 调整窗口大小事件

![63526166759](assets/1635261667593.png)

 



#### 定时器setTimeout()

![63533837992](assets/1635338379921.png)

#### 清除定时器

![63533875254](assets/1635338752548.png)

#### 定时器setInterval()  重复调用

![63533888447](assets/1635338884479.png)



#### this指向问题

指向的是调用它的对象

全局作用域下，变量或函数实际都是全局对象window的属性,只是写的时候会省略window,所以指向window

在定时器里也是指向window，因为定时器是window的属性 window.setTimeout

![63533997171](assets/1635339971711.png)

方法调用中谁调用this指向谁

![63534009943](assets/1635340099438.png)

构造函数中this指向实例对象

![63534017750](assets/1635340177508.png)



#### 同步异步

![63534076743](assets/1635340767436.png)

![63534080234](assets/1635340802345.png)

![63534084326](assets/1635340843262.png)

定时任务或者click点击等回调函数，会先进入异步进程，当定时任务倒计时结束或触发回调函数时，任务才会进入任务队列(异步队列)，然后由主线程执行完主线程任务后查询异步队列的任务再执行

![63534130808](assets/1635341308080.png)

Js单线程：

在浏览器的一个页面中，该页面的的Js只有一个master主线程[Js脚本运行在上面]（注意：Js是单线程，**但浏览器内部并不是单线程**，I/O、定时器、事件监听等都是浏览器的其他线程完成的），所以叫单线程。

因为Js是单线程，所以程序的执行顺序都是从上到下依次进行的，同一时间内只能有一段代码被执行。


![63534164827](assets/1635341648271.png)

![63534227293](assets/1635342272935.png)

#### navigator对象

![63534247913](assets/1635342479134.png)

#### history对象

![63534259649](assets/1635342596490.png)



#### 元素偏移量offset

![63534399996](assets/1635343999963.png)

![63534563931](assets/1635345639317.png)

#### 元素client

边框指border ，和offsetWidth区别在包不包含边框

![63534991754](assets/1635349917540.png)



#### 立即执行函数

![63558528235](assets/1635585282352.png)

独立作用域，主要指函数名的声明(可以不给函数名也可以给)，不会影响到全局变量，不会被添加到全局变量里，所以用立即执行函数即使添加了函数名，在全局作用域也不能通过函数名再次调用方法(可用于初始化)

![63558602946](assets/1635586029465.png)



#### scroll属性

![63558846533](assets/1635588465331.png)

![63558905433](assets/1635589054333.png)

![63558933697](assets/1635589336976.png)



#### mouseenter 鼠标事件(移动到元素上时触发，mouseover)

mouseenter不会冒泡 只触发一次

![63559092875](assets/1635590928752.png)







## 动画

![63559119371](assets/1635591193716.png)



#### 节流阀(例如防止轮播图按钮连续点击播放过快)

![63566286086](assets/1635662860866.png)



#### 移动端触屏事件

![63566500052](assets/1635665000529.png)

#### 触摸事件对象(TouchEvent)

![63566553345](assets/1635665533450.png)



#### 用css的translateX代替动画函数

**transitionend**可用来监听过渡完成事件

![63566879054](assets/1635668790541.png)



#### classList 可以添加或切换类名(H5新增 相对classname可以追加类名不覆盖)

切换：有则删除，没有则添加

![63566933116](assets/1635669331169.png)



#### 移动端click延时解决方案

![63567166477](assets/1635671664778.png)

![63567168540](assets/1635671685404.png)

解决方案三：fastclick插件







#### swiper插件(移动端滑动效果插件)

![63567400388](assets/1635674003887.png)







## 本地存储

window.**sessionStorage**

![63567592180](assets/1635675921800.png)

**localStorage**

 ![63567610394](assets/1635676103943.png)

